# Boas-vindas ao exerc√≠cio Trybe RPG Battle

---

# Orienta√ß√µes

<details>
  <summary><strong>‚ÄºÔ∏è Antes de come√ßar a desenvolver</strong></summary><br />

- Crie um fork desse projeto. Para isso, siga este [tutorial de como realizar um fork](https://guides.github.com/activities/forking/).

- Ap√≥s fazer o fork, clone o reposit√≥rio criado para seu computador.

- Rode o comando `npm install`.

- V√° para a branch `main` de seu projeto e execute o comando `git branch` ou `git branch -a`.

> üí° Observe o que deve ser feito nas instru√ß√µes para cada exerc√≠cio.

</details>

<br />

<details>
  <summary><strong>ü§ù Depois de terminar o desenvolvimento</strong></summary><br />

Ap√≥s a solu√ß√£o dos exerc√≠cios, abra um PR em seu reposit√≥rio forkado e, se quiser, mergeie para a `main`. Sinta-se √† vontade!

**Aten√ß√£o**: Ao criar o PR, voc√™ vai se deparar com esta tela:

![PR do exerc√≠cio](images/example-pr.png)

√â necess√°rio realizar uma mudan√ßa. Para isso, clique no _base repository_, assim como na imagem a seguir.

![Mudando a base do reposit√≥rio](images/change-base.png)

Mude para seu reposit√≥rio. Seu nome estar√° na frente do nome dele, por exemplo: `antonio/TicTacToe`. Depois desse passo, a p√°gina deve ficar assim:

![Ap√≥s mudan√ßa](images/after-change.png)

Agora, basta criar o PULL REQUEST clicando no bot√£o `Create Pull Request`.

> üí° Realize esse processo para cada PR que abrir.

</details>

<br />


<details>
  <summary><strong>üë®‚Äçüíª O que dever√° ser desenvolvido</strong></summary><br />

Nesse reposit√≥rio, voc√™ encontra uma aplica√ß√£o React funcionando que simula, de maneira simplificada, como funciona uma batalha de RPG, na qual voc√™ pode escolher atacar v√°rios personagens.

Al√©m disso, antes de atacar, voc√™ pode configurar quantos e qual o tamanho dos dados que voc√™ quer rolar contra seus inimigos. Ap√≥s o ataque, voc√™ saber√° se venceu ou se teve uma derrota. 

Neste exerc√≠cio, al√©m das batalhas √©picas contra personagens famosos, voc√™ ter√° o desafio de criar testes para as fun√ß√µes que geram os n√∫meros aleat√≥rios e para as requisi√ß√µes feitas √† API externa. Prepare seu D20 e comece esta aventura!

Verifique com aten√ß√£o a implementa√ß√£o das fun√ß√µes a seguir, pois voc√™ vai desenvolver testes para elas:

- `service/rollDice.ts`
- `service/rollMultipleDice.ts`
- `service/attackEnemy.ts`

</details>

<br />

# Exerc√≠cios

## Exerc√≠cio 1

Verifique o arquivo `service/rollDice.ts`. Ele implementa uma fun√ß√£o `rollDice`, a qual faz uma simula√ß√£o como se uma pessoa estivesse rolando um dado. Ou seja, a fun√ß√£o retorna um n√∫mero aleat√≥rio entre 1 e o valor m√°ximo do dado (definido por meio de um par√¢metro chamado `size`).

Para gerar o n√∫mero aleat√≥rio, √© usada a fun√ß√£o `Math.random`, al√©m de alguns outros c√°lculos para garantir que o n√∫mero esteja dentro do intervalo estabelecido.

Testar o retorno de uma fun√ß√£o que usa valores rand√¥micos n√£o √© poss√≠vel, j√° que seu resultado n√£o √© previs√≠vel - a menos que voc√™ utilize um `mock` para ter o controle desses valores aleat√≥rios.

<details>
  <summary>Crie os testes para a fun√ß√£o <code>rollDice</code> do arquivo <code>service/dice.ts</code>.</summary><br />
  
- Considere um dado de tamanho 20 para este teste.
- Crie um mock para a fun√ß√£o `Math.random`, de modo que a fun√ß√£o `rollDice` sempre retorne o n√∫mero 16.
- Teste se o valor retornado pela fun√ß√£o √© igual a 16.
- Teste se a fun√ß√£o `Math.random` foi chamada uma √∫nica vez.

</details>

## Exerc√≠cio 2

Dentro do arquivo `service/rollMultipleDice.ts` existe a fun√ß√£o `rollMultipleDice`, que simula como se a pessoa estivesse rolado v√°rios dados ao mesmo tempo. Ela recebe como par√¢metro quantos dados foram rolados e qual o tamanho dos dados. Para gerar o valor de cada dado, a fun√ß√£o `rollMultipleDice` usa internamente a fun√ß√£o `rollDice`.

<details>
  <summary>Crie os testes para a fun√ß√£o <code>rollMultipleDice</code> que √© exportada no arquivo <code>service/rollMultipleDice.ts</code></summary><br />

- Use o `jest.mock` para *mockar* o m√≥dulo `service/rollDice`. Lembre-se de passar como argumento o caminho do arquivo.
- A fun√ß√£o `rollDice` dever√° ser *mockada* de modo que a primeira vez que ela for chamada dever√° retornar `6` e, da segunda vez em que ela for chamada, dever√° retornar `4`.
- Considere um dado de tamanho 20 para este teste.
- Verifique se o valor retornado pela fun√ß√£o `rollMultipleDice` √© a somat√≥ria de `6` + `4`, ou seja, `10`.
- Verifique se a fun√ß√£o `rollDice` foi chamada duas vezes.

</details>

## Exerc√≠cio 3
A fun√ß√£o `attackEnemy` simula um ataque a um inimigo. Ainda, ela compara os resultados dos dados que voc√™ rolou (da fun√ß√£o `rollMultipleDice`) com a defesa do inimigo.

- A fun√ß√£o `attackEnemy` recebe **3 argumentos**: `diceQuantity`, `diceSize` e um objeto `enemy`.
  - Esse √© um exemplo de `enemy`: 
    ```javascript 
    const enemy = {
      id: 1,
      name: "Chapolin Colorado",
      source: "Chaves",
      defensePoints: 30
    }
    ``` 
- O **retorno** dessa fun√ß√£o √© um objeto que tem a chave `success` - que ser√° `true` ou `false` dependendo do resultado da batalha.  

No exemplo do Chapolin, com 30 pontos de defesa, voc√™ precisar√° tirar nos dados um valor maior que 30 para ganhar. Nesse caso, temos tr√™s cen√°rios que podem ser testados: 

1. Voc√™ tira nos dados um valor menor que `30` = derrota.
2. Voc√™ tira nos dados um valor maior que `30` = vit√≥ria.
3. Voc√™ tira nos dados um valor igual a `30` = derrota.  

Neste exerc√≠cio, voc√™ dever√° testar a fun√ß√£o attackEnemy para esses tr√™s casos, seguindo os passos a seguir. 

<details>
  <summary>Crie os testes para a fun√ß√£o <code>attackEnemy</code>, que √© exportada no arquivo <code>service/attackEnemy.ts</code></summary><br />

- Use o  `jest.mock` para *mockar* o m√≥dulo `service/rollMultipleDice.ts`. Lembre-se de passar como argumento o caminho do arquivo.
- Em todos os testes voc√™ dever√° testar o resultado da fun√ß√£o `attackEnemy`.

- Crie um teste para o caso de **vit√≥ria**:
  - a fun√ß√£o `rollMultipleDice` dever√° ser *mockada* de modo que a primeira vez que ela for chamada dever√° retornar um valor maior do que a defesa do inimigo.
  - o resultado da batalha dever√° ser a vit√≥ria.
  
- Crie um teste para o caso de **derrota**:
  - a fun√ß√£o `rowMultipleDice` dever√° ser *mockada* de modo que a primeira vez que ela for chamada dever√° retornar um valor menor do que a defesa do inimigo.
  - o resultado da batalha dever√° ser a derrota.

- Crie um teste para o caso de **empate nos dados**:
  - a fun√ß√£o `rowMultipleDice` dever√° ser *mockada* de modo que a primeira vez que ela for chamada dever√° retornar um valor igual ao da defesa do inimigo.
  - o resultado da batalha dever√° ser a derrota.

</details>

## Exerc√≠cio 4

Os personagens usados nas batalhas chegam √† sua aplica√ß√£o por meio de uma API. Quando a aplica√ß√£o √© renderizada, uma requisi√ß√£o √© feita e uma lista de personagens √© preenchida no estado.

Neste exerc√≠cio, voc√™ criar√° um teste _mockando_ a chamada da API de modo que seja retornada uma lista com apenas um personagem (de seu mock).

<details>
  <summary>Crie um teste renderizando a aplica√ß√£o e mockando o retorno da API</summary><br />

- Fa√ßa um _mock_ na fun√ß√£o `fetch` para que a requisi√ß√£o para a API de personagens retorne apenas um personagem.
- Renderize a aplica√ß√£o e verifique se o nome de seu personagem est√° sendo exibido na tela. O nome do personagem √© renderizado em um elemento `h3`. Dica: use o `getByRole` para pegar esse elemento.

</details>
